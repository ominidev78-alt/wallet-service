import { pool } from '../config/db.js'export class LedgerModel {  static async addEntry({     walletId,     direction,     amount,     description,     meta,     externalId   }: {     walletId: number | string;     direction: string;     amount: number;     description?: string | null;     meta?: any;     externalId: string   }): Promise<any> {    if (!externalId) {      throw new Error('external_id is required for ledger entries')    }    const { rows } = await pool.query(      `      INSERT INTO ledger_entries (        wallet_id,        direction,        amount,        description,        meta,        external_id,        created_at      )      VALUES (        $1,        $2,        $3,        $4,        $5::jsonb,        $6,        NOW()      )      RETURNING *;      `,      [        walletId,        direction,        amount,        description || null,        JSON.stringify(meta || {}),        externalId      ]    )    return rows[0]  }  static async getWalletEntries(walletId: number | string, limit: number = 100): Promise<any[]> {    const { rows } = await pool.query(      `      SELECT        id,        wallet_id,        direction,        amount,        description,        meta,        external_id,        created_at      FROM ledger_entries      WHERE wallet_id = $1      ORDER BY id DESC      LIMIT $2;      `,      [walletId, limit]    )    return rows  }  static async getWalletSummary(walletId: number | string): Promise<{ total_credit: number; total_debit: number }> {    const { rows } = await pool.query(      `      SELECT        COALESCE(SUM(CASE WHEN direction = 'CREDIT' THEN amount ELSE 0 END), 0) AS total_credit,        COALESCE(SUM(CASE WHEN direction = 'DEBIT' THEN amount ELSE 0 END), 0) AS total_debit      FROM ledger_entries      WHERE wallet_id = $1;      `,      [walletId]    )    return rows[0]  }  static async findById(entryId: number | string): Promise<any | null> {    const { rows } = await pool.query(      `      SELECT *      FROM ledger_entries      WHERE id = $1      LIMIT 1;      `,      [entryId]    )    return rows[0] || null  }  static async isTransactionProcessed(    walletId: number | string,     merOrderNo?: string | null,     orderNo?: string | null,     tradeNo?: string | null  ): Promise<boolean> {    const conditions = []    const params: any[] = [walletId]    let paramIndex = 2    if (merOrderNo) {      conditions.push(`meta->>'merOrderNo' = $${paramIndex}`)      params.push(merOrderNo)      paramIndex++    }    if (orderNo) {      conditions.push(`meta->>'orderNo' = $${paramIndex}`)      params.push(orderNo)      paramIndex++    }    if (tradeNo) {      conditions.push(`(meta->>'tradeNo' = $${paramIndex} OR meta->>'e2e' = $${paramIndex})`)      params.push(tradeNo)      paramIndex++    }    if (conditions.length === 0) {      return false    }    const whereClause = conditions.join(' OR ')    const { rows } = await pool.query(      `      SELECT id      FROM ledger_entries      WHERE wallet_id = $1        AND (${whereClause})      LIMIT 1;      `,      params    )    return rows.length > 0  }  static async findOriginalTransaction(    walletId: number | string,     merOrderNo?: string | null,     externalId?: string | null  ): Promise<any | null> {    const conditions = []    const params: any[] = [walletId]    let paramIndex = 2    if (merOrderNo) {      conditions.push(`meta->>'merOrderNo' = $${paramIndex}`)      params.push(merOrderNo)      paramIndex++    }    if (externalId) {      conditions.push(`external_id = $${paramIndex}`)      params.push(externalId)      paramIndex++    }    if (conditions.length === 0) {      return null    }    const whereClause = conditions.join(' OR ')    const { rows } = await pool.query(      `      SELECT         id,        external_id,        meta,        amount,        direction,        created_at      FROM ledger_entries      WHERE wallet_id = $1        AND (${whereClause})        AND direction = 'CREDIT'      ORDER BY id ASC      LIMIT 1;      `,      params    )    if (rows.length === 0) {      return null    }    const entry = rows[0]    const meta = typeof entry.meta === 'string' ? JSON.parse(entry.meta) : entry.meta    return {      externalId: entry.external_id,      merOrderNo: meta?.merOrderNo || merOrderNo,      orderNo: meta?.orderNo || externalId,      tradeNo: meta?.tradeNo || meta?.e2e || merOrderNo,      amount: entry.amount,      meta    }  }  static async updateMeta(walletId: number | string, externalId: string, newMeta: any): Promise<boolean> {    const { rowCount } = await pool.query(      `      UPDATE ledger_entries      SET meta = meta || $3::jsonb      WHERE wallet_id = $1 AND external_id = $2;      `,      [walletId, externalId, JSON.stringify(newMeta)]    )    return (rowCount ?? 0) > 0  }}
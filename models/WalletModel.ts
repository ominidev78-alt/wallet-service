import { pool } from '../config/db.js'import { LedgerModel } from './LedgerModel.js'import { Wallet } from '../types/wallet.js'export class WalletModel {  static async createUserWallet(userId: number | string, currency: string = 'BRL'): Promise<Wallet> {    const { rows } = await pool.query(      `      INSERT INTO wallets (user_id, type, currency, balance)      VALUES ($1, 'USER', $2, 0)      RETURNING *;      `,      [userId, currency]    )    return rows[0]  }  static async getUserWallet(userId: number | string, currency: string = 'BRL'): Promise<Wallet | null> {    const { rows } = await pool.query(      `      SELECT *      FROM wallets      WHERE user_id = $1        AND type = 'USER'        AND currency = $2      ORDER BY id ASC      LIMIT 1;      `,      [userId, currency]    )    return rows[0] || null  }  static async updateBalance(walletId: number | string, newBalance: number): Promise<Wallet> {    const { rows } = await pool.query(      `      UPDATE wallets      SET balance = $2      WHERE id = $1      RETURNING *;      `,      [walletId, newBalance]    )    return rows[0]  }  static async getById(walletId: number | string): Promise<Wallet | null> {    const { rows } = await pool.query(      `      SELECT *      FROM wallets      WHERE id = $1      LIMIT 1;      `,      [walletId]    )    return rows[0] || null  }  static async getHouseWalletByUserId(userId: number | string, currency: string = 'BRL'): Promise<Wallet | null> {    const { rows } = await pool.query(      `      SELECT *      FROM wallets      WHERE user_id = $1        AND type = 'HOUSE'        AND currency = $2      ORDER BY id ASC      LIMIT 1;      `,      [userId, currency]    )    return rows[0] || null  }  static async createHouseWallet(userId: number | string, currency: string = 'BRL'): Promise<Wallet> {    const existing = await this.getHouseWalletByUserId(userId, currency)    if (existing) return existing    const { rows } = await pool.query(      `      INSERT INTO wallets (user_id, type, currency, balance)      VALUES ($1, 'HOUSE', $2, 0)      RETURNING *;      `,      [userId, currency]    )    return rows[0]  }  static async getOrCreateHouseWallet(userId: number | string, currency: string = 'BRL'): Promise<Wallet> {    const existing = await this.getHouseWalletByUserId(userId, currency)    if (existing) return existing    return await this.createHouseWallet(userId, currency)  }  static async credit(walletId: number | string, { amount, description, meta, externalId }: { amount: number, description?: string | null, meta?: any, externalId: string }): Promise<number> {    const wallet = await this.getById(walletId)    if (!wallet) throw new Error('Wallet not found')    if (!externalId) {      throw new Error('external_id is required for credit operations')    }    const currentBalance = Number(wallet.balance) || 0    const newBalance = currentBalance + Number(amount)    await this.updateBalance(walletId, newBalance)    await LedgerModel.addEntry({      walletId,      direction: 'CREDIT',      amount: Number(amount),      description,      meta: {        ...meta,        previousBalance: currentBalance,        newBalance      },      externalId    })    return newBalance  }  static async debit(walletId: number | string, { direction = 'DEBIT', amount, description, meta, externalId }: { direction?: string, amount: number, description?: string | null, meta?: any, externalId: string }): Promise<number> {    const wallet = await this.getById(walletId)    if (!wallet) throw new Error('Wallet not found')    if (!externalId) {      throw new Error('external_id is required for debit operations')    }    const currentBalance = Number(wallet.balance) || 0    const debitAmount = Number(amount)    if (currentBalance < debitAmount) {      throw new Error('Insufficient funds')    }    const newBalance = currentBalance - debitAmount    await this.updateBalance(walletId, newBalance)    await LedgerModel.addEntry({      walletId,      direction,      amount: debitAmount,      description,      meta: {        ...meta,        previousBalance: currentBalance,        newBalance      },      externalId    })    return newBalance  }  static async mutateBalance(walletId: number | string, { amount, description, meta, externalId }: { amount: number, description?: string | null, meta?: any, externalId: string }): Promise<number> {    const wallet = await this.getById(walletId)    if (!wallet) throw new Error('Wallet not found')    if (!externalId) {      throw new Error('external_id is required for mutate operations')    }    const currentBalance = Number(wallet.balance) || 0    const newBalance = currentBalance + Number(amount)    await this.updateBalance(walletId, newBalance)    await LedgerModel.addEntry({      walletId,      direction: amount >= 0 ? 'CREDIT' : 'DEBIT',      amount: Math.abs(Number(amount)),      description,      meta: {        ...meta,        previousBalance: currentBalance,        newBalance      },      externalId    })    return newBalance  }}